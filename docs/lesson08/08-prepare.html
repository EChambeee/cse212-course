<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <link rel="stylesheet" type="text/css" href="../site/style.css" />
    <title>CSE 212 - 08 Prepare</title>
</head>
<body>
    <header id="courseTitle">
        <span class="icon-byui-logo"></span>
        <h1>CSE 212 | Programming with Data Structures</h1>
    </header>
    <article>
		<h1>08 Prepare : Reading</h1>
				
		<h2>Table of Contents</h2>
		<p><a href="#1">Recursion</a></p>
			<ul>
			<li><p><a href="#1.1">Recursive Function Calls</a></p></li>				
			<li><p><a href="#1.2">Rules of Recursion</a></p></li>
			<li><p><a href="#1.3">Sample Problems - Factorials</a></p></li>
			<li><p><a href="#1.4">Sample Problems - Fibonacci</a></p></li>
			<li><p><a href="#1.5">Sample Problems - Find Combinations</a></p></li>
			<li><p><a href="#1.6">Sample Problems - MergeSort</a></p></li>
		</ul>
        <p><a href="#2">Key Terms</a></p>
		
		<h2 id="1">Recursion</h2>
		<h3 id="1.1">Recursive Function Calls</h3>
		<p>Usually when we write functions, we design them so they call different functions.  <strong>Recursion</strong> is a technique where a function calls itself.  For example, consider the following code:</p>
		
		<pre><code class="Python">
def say_hello():
	print("Hello")
	say_hello()  # This is the recursive call
		</code></pre>		
		
		<p>This code will print "Hello" forever.  Actually, Python will eventually stop with a <code>RecursionError</code> because the <code>say_hello</code> function was called too many times.  Notice that in this function, the first call to <code>say_hello</code> never has a chance to finish.  In software, when a function is called, it is put onto a stack.  The stack is used to keep track of what function to go back to when a function finishes.  In this case, the stack is filling up.</p>
		
		<h3 id="1.2">Rules of Recursion</h3>
		<p>When we use recursion, we need to make sure we follow two important rules:</p>
		<ul>
			<li><p>Smaller Problem - When we call the function recursively, we need to make sure we are calling the function on a smaller problem.  Without this rule, our function will run forever.</p></li>
			<li><p>Base Case - As we continue to call the function on a smaller problem, we need a place to stop.  We must define a scenario in which recursion is not required.  This is called the <strong>base case</strong>.</p></li>
		</ul>
		
		<p>Applying these two rules to the <code>say_hello</code> function, we have the following modified code which is keeping track of how many times to say "Hello":</p>
		
		<pre><code class="Python">
def say_hello(count):
	if count &lt;= 0:  # Base Case
		return
	else:
		print("Hello")
		say_hello(count-1)  # Smaller Problem
		</code></pre>		
		
		<p>In this new code, the smaller problem is <code>count-1</code> and the base case is when count is equal (or less than) zero.  When we look at this code, we should probably question the use of recursion when this could have been done with a simple <code>for</code> loop.  Recursion should not be used with everything.  When used inappropriately, recursion can result is significant performance degradation.  However, when used wisely, a simple code solution can be found for complex problems.</p>
		
		<h3 id="1.3">Sample Problems - Factorials</h3>
		
		<p>Solving problems using recursion requires us to state the solution of a problem in terms of the problem itself (i.e., calling the function recursively).  Some problems in mathematics offer good examples of recursion (performance is questionable, but the examples are sound).</p>
		
		<p>A factorial involves multiplying a series of numbers.  For a positive integer <code>n</code> (greater than 0), <code>n</code>! (read as <code>n</code> factorial) is defined as <code>n</code> * (<code>n</code>-1) * (<code>n</code>-2) * ... * 3 * 2 * 1.  If we wanted to calculate <code>n</code>! using recursion, we need to define the answer in terms of the problem again.  The "problem" here is the factorial function.  We can rewrite <code>n</code>! as follows:</p>
		<p><code>n</code>! = <code>n</code> * (<code>n</code>-1)!</p>
		<p>This solution above satisfies the first rule of recursion.  To satisfy the second rule of recursion, we need to define <code>n</code>! for some value of <code>n</code> without using recursion so that our solution does not run forever.  Without much math, we can solve 1! and say that it is equal to 1.  We now have a base case.  With our solution and base case, we can write the code:</p>
		
		<pre><code class="Python">		
def factorial(n):
	if n &lt;= 1:
		return 1  # 1! = 1 (no recursion)
	else:
		return n * factorial(n-1)  # n! = n * (n-1)!
		</code></pre>		
		
		<h3 id="1.4">Sample Problems - Fibonacci</h3>
		
		<p>The Fibonacci numbers are: 1, 1, 2, 3, 5, 8, 13, 21, 34, and so forth.  The sequence starts with two 1's.  Each subsequent number is the sum of the two previous values.  If we wanted to write a function <code>fib(n)</code> which would give us the <code>n</code>th Fibonacci number, instead of thinking about loops, let's define <code>fib(n)</code> in terms of the same <code>fib</code> problem but with smaller values:</p>
		
		<p><code>fib(n)</code> = <code>fib(n-1)</code> + <code>fib(n-2)</code></p>
		
		<p>If we implement this, eventually we will get to calls of the <code>fib</code> function with smaller values of <code>n</code>.  These smaller values of <code>n</code> represent the base case for recursion solution.  Usually we try to think about solutions that we can easily calculate such as <code>fib(1) </code> which will equal 1.  However, if we look at our formula above, we will need more than one base case.  Consider <code>n</code>=3 which will require us to use <code>fib(2)</code> and <code>fib(1)</code>.  If we then recursively solve for <code>fib(2)</code>, we will need <code>fib(1)</code> and <code>fib(0)</code>.  In cases like this, we will need more than one base case representing the first two Fibonacci numbers:</p>
		
		<p><code>fib(2)</code> = 1</p>
		<p><code>fib(1)</code> = 1</p>
		
		<p>Our resulting code will be as follows:</p>
		
		<pre><code class="Python">		
def fib(n):
	if n &lt;= 2:   
		return 1    # fib(2) = 1 and fib(1) = 1
	else:
		return fib(n-1) + fib(n-2)  # fib(n) = fib(n-1) + fib(n-2)
		</code></pre>		
		
		<p>It is a useful exercise to analyze what happens when we call the <code>fib</code> function.  The diagram below shows the functions that are called when we run <code>fib(6)</code>.  Notice that the call to <code>fib(n-1)</code> is called before <code>fib(n-2)</code> and, therefore, the <code>fib(n-1)</code> must finish first.  Also notice that there are many duplicate calls to the <code>fib</code> function for the same value of <code>n</code>.</p>
		
        <figure>
		<img src="fib6_recursion.jpeg" width="100%" height="100%" alt="Shows all the functions called by fib(6).  fib(6) calls fib(5) and fib(4).  fib(5) calls fib(4) and fib(3).  fib(4) calls fib(3) and fib(2).  fib(3) calls fib(2) and fib(1).  The total calls to the fib function (including the original fib(6)) is 15.">
        <figcaption>Recursive Function Calls for fib(6)</figcaption></figure>
        
		<p>The <code>fib</code> function was called a total of 15 times!  This is an O(2^n) algorithm.</p>
		
		<h3 id="1.5">Sample Problems - Find Combinations</h3>
		
		<p>The problem is to calculate the number of combinations of different letters in a word.  Mathematically, this should be <code>n!</code> where <code>n</code> is the number of letters in the word.  However, using recursion, we can also display each of the combinations (so long as the number of letters is small, otherwise it will take a long time to display all the results).  This problem, though, allows us to demonstrate a more complicated recursion problem and show a technique of remembering past results.</p>
		<p>Let's assume that our list of letters is ["A", "B", "C", "D"].  Thinking about smaller problems being solved recursively, we could say that the number of combinations would be the sum of the following four things:</p>
		<ul>
		<li><p>The number of combinations of A followed by all the different combinations of B, C, and D</p></li>
		<li><p>The number of combinations of B followed by all the different combinations of A, C, and D</p></li>
		<li><p>The number of combinations of C followed by all the different combinations of A, B, and D</p></li>
		<li><p>The number of combinations of D followed by all the different combinations of A, B, and C</p></li>
		</ul>
		<p>Each recursive call to the <code>combinations</code> function will need to know two things: what letters have not been used yet, and the current string that has been built so far.  In the four scenarios above, after we add the A, we are left with the letters B, C, and D (the letters that have not been used yet).  Additionally, after we add the A, the A should be added to the current string that we have built.</p>
		<p>We also need a base case.  The simplest scenario is a list with one letter.  The result of <code>combinations(["A"])</code> would be one.  Here is our code (note that the printing out of the string should be commented out for large list of letters):</p>
		
		<pre><code class="Python">		
def combinations(letters, word_so_far=""):

	if len(letters) == 1:   # Base Case
		print(word_so_far + letters[0])  
		return 1

	else:
		# Try adding each of the available letters
		# to the 'word_so_far' and add up all the
		# resulting combinations.

		total = 0
		for index in range(len(letters)):
			# Make a copy of the letters to pass to the
			# the next call to combinations.  We need
			# to remove the letter we just added before
			# we call combinations again.

			letters_left = letters[:]
			del letters_left[index]

			# Add the new letter to the word we have so far
			total += combinations(letters_left, word_so_far + letters[index])
	return total

print(combinations(list("ABC")))       # 6
print(combinations(list("ABCDEFG")))   # 5040					
		</code></pre>		

		<p>If we try a longer list of letters, this recursive algorithm slows down significantly.  Reflecting back on the Fibonacci problem, the diagram of function calls showed many duplicate calls to the <code>fib</code> function for the same value of <code>n</code>.  Likewise, in the <code>combinations</code> function, there are many duplciate calls to the function for the same value of <code>letters</code>.  To solve this problem, we will use a dictionary to remember the results of calling <code>combinations</code>.  Before we do a recursive call, we will check our dictionary to see if we have solved that part of the problem already before.  In a way, this becomes another base case.  Our faster code now looks like this:</p>
		
		<pre><code class="Python">		
def combinations(letters, word_so_far="", remember=dict()):

	# The key in the dictionary will be a string
	# made up of the letters in the list.  We will use
	# this several times in the function so a variable
	# will be useful.
	remember_key = str(letters) 

	if len(letters) == 1:   # Base Case
		#print(word_so_far + letters[0])  
		return 1

	elif remember_key in remember:  # Have we seen this before?
		return remember[remember_key]

	else:
		# Try adding each of the available letters
		# to the 'word_so_far' and add up all the
		# resulting combinations.
		total = 0

		for index in range(len(letters)):
			# Make a copy of the letters to pass to the
			# the next call to combinations.  We need
			# to remove the letter we just added before
			# we call combinations again.

			letters_left = letters[:]
			del letters_left[index]

			# Add the new letter to the word we have so far
			total += combinations(letters_left, 
					word_so_far + letters[index], 
					remember)

	# Remember this result for later
	remember[remember_key] = total

	return total

print(combinations(list("ABCDEFGHIJKLMNOP"))) # 20922789888000 			
		</code></pre>		

		<h3 id="1.6">Sample Problems - MergeSort</h3>
		
		<p>Recursion plays an important role in several data structures and sorting algorithms.  One of the common sorting algorithms is called MergeSort.  MergeSort is based on the following process:</p>
		
		<ul>
		<li><p>Split up a list into multiple smaller lists.  This is done by recursively cutting the list in half to make two smaller lists.  The splitting stops when we get to a list of size 1 (the base case).  Note that a list of size 1 is sorted.</p></li>
		<li><p>Merge the lists back together again.  When this merging begins, it will be sorting two lists of size 1.  The result will be a sorted list of size 2.  As the merging continues, sorted lists of larger size will be merged together.  The process of merging two sorted lists into a single sorted list was one of the problems from the first week of the semester.</p></li>
		</ul>
		
		<p>Here is the code for MergeSort.  Notice the recursion with the smaller problem (smaller lists) and the base case:</p>
		 
		<pre><code class="Python">
def merge_sort(data):
    if len(data) &lt;= 1:
        return
    middle = len(data) // 2
    left = data[:middle]    # First half using list slicing
    right = data[middle:]   # Second half using list slicing
    
    merge_sort(left)  # Recursively sort the left side
    merge_sort(right) # Recursively sort the right side

    # At this point, left and right are now sorted!
    # Now we need to merge them back together again
    # The code below is one solution for merging two sorted lists together

    left_pos = 0
    right_pos = 0
    merge_pos = 0
    # Select the smallest from left and right until we finish one side
    while (left_pos &lt; len(left)) and (right_pos &lt; len(right)):
        if left[left_pos] &lt; right[right_pos]:
            data[merge_pos] = left[left_pos]
            left_pos += 1
        else:
            data[merge_pos] = right[right_pos]
            right_pos += 1
        merge_pos += 1
    # Copy over the other side that we have finished yet
    if left_pos &lt; len(left):
        data[merge_pos:] = left[left_pos:]
    elif right_pos &lt; len(right):
        data[merge_pos:] = right[right_pos:]

data = [3, 1, 6, 2, 9, 8, 4]
merge_sort(data)
print(data)  # [1, 2, 3, 4, 6, 8, 9]
		</code></pre>
		
		<p>The performance of this recursive algorithm is O(n log n).  The O(log n) occurs because the recursion is splitting the list in half.  The O(n) occurs because of the algorithm to merge the two sorted lists together.  Many of the algorithms related to data structures and sorting that use recursion result in performance of either O(log n) or O(n log n).  These solutions are preferred over those that give O(n) or O(n^2).</p>
        
        <h2 id="2">Key Terms</h2>
        
        <ul>
        <li><p><strong>base case</strong> - The scenario that will terminate (or stop) the recursive calls.  If this is not designed properly, then the recursion will run forever.</p></li>
        <li><p><strong>recursion</strong> - The calling of a function with the same function.  This can be used to solve problems by identifying a solution which is written in terms of solving the same problem using smaller values.  A base case is needed to ensure that the recursion eventually stops.  The base cases are solved in the function without using recursion.</p></li>
        </ul>
		
		<script src="../site/js/highlight/highlight.pack.js"></script>
		<script>hljs.initHighlightingOnLoad();</script>

		
    </article>
</body>
</html>